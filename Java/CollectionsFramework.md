# 컬렉션 프레임워크

다수의 데이터(데이터 그룹)를 저장하는 클래스들을 표준화한 설계

<br/>

### 컬렉션 프레임워크의 핵심 인터페이스 - `List`, `Set`, `Queue`, `Map`

컬렉션 프레임워크에서는 컬렉션데이터 그룹을 크게 3가지 타입으로 구분하고, 각 컬렉션데이터를 다루는데 필요한 기능을 가진 3개의 인터페이스를 정의하였다.

3개의 인터페이스 중 `List`와 `Set`, `Queue`의 공통된 부분을 뽑아서 `Collection` 인터페이스를 추가로 정의하였다.

**List 구현 클래스**
- `ArrayList`, `LinkedList`, `Stack`, `Vector` 등

**Set 구현 클래스**
- `HashSet`, `TreeSet` 등

**Queue 구현 클래스**
- `BlockingQueue`, `Deque`

**Map 구현 클래스**
- `HashMap`, `TreeMap`, `Hashtable`, `Properties` 등

<br/>

### List 인터페이스

중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용된다

<br/>

**`ArrayList`**

- 데이터를 읽어 오는데 걸리는 시간(접근시간, access time)이 빠르다
- 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존 배열에 저장된 내용을 새로운 배열로 복사한다 → 처음에 인스턴스를 생성할 때 충분한 용량의 인스턴스를 생성하는 것이 좋다
- 용량을 변경할 때 복사를 하기 때문에 효율이 떨어질 수 있다
- 충분히 큰 용량의 인스턴스를 생성할 때 메모리가 낭비될 수 있다
- 중간의 데이터를 추가, 삭제하려면 데이터들을 이동시켜야 하기 때문에 데이터가 많을수록 작업시간이 오래 걸린다

<br/>

**`LinkedList`**

- 실제는 양방향 링크드 리스트로 구현되어 있다 → 링크드 리스트의 낮은 접근성을 보완
- `Deque` 인터페이스(`Queue`를 상속받는)를 구현하기 때문에 큐의 특징을 활용할 수 있는 메서드들을 구현하고 있다
- 원소를 찾으려면 차례대로 참조를 따라가야한다

<br/>

## `Arrays`

- `Arrays` 클래스에는 배열을 다루는데 유요한 메서드가 정의되어 있다
  - 배열의 복사 - `copyOf()`, `copyOfRange()`
  - 배열 채우기 - `fill()`, `setAll()`
  - 배열의 정렬과 검색 - `sort()`, `binarySearch()`
  - 배열의 모든 요소를 문자열로 - `toString()`, `deepToString()`
  - 배열이 같은지 비교 - `equals()`, `deppToEquals()`
  - 배열을 리스트로 - `asList()`
  - 여러 스레드가 작업을 나누어 처리하도록 - `parallelXXX()`
  - 하나의 작업을 어려 작업으로 나누는 - `spliterator()`
  - 컬렉션을 스트림으로 변환하는 - `stream()`
- `Arrays`에 정의된 메서드는 모두 static 메서드이다


<br/>

---

<br/>

출처
- Java의 정석 (남궁 성)
- [생활코딩 - 배열과 컬렉션즈 프레임워크](https://opentutorials.org/course/1223/6446)