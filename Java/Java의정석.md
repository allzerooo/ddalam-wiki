# Java의 정석

- [반복문](#iteration)
- [배열](#array)
- [객체지향프로그래밍](#object-oriented-programming)
- [예외처리(exception handling)](#exception-handling)

<br/>

## <a name="iteration"></a>반복문

### for문

- 둘 이상의 변수가 필요할 때 콤마를 구분자로 변수를 초기화 (단, 두 변수의 타입은 같아야 한다)
- 증감식도 콤마를 이용해 두 문장 이상을 하나로 연결해 쓸 수 있다
  ```java
  for(int i = 1, j = 10; i <= 10; i++, j--) { ... }
  ```

### 향상된 for문

- 배열과 컬렉션에 저장된 요소를 읽어오는 용도로만 사용할 수 있다

### while문

- `while`문의 조건식은 생략불가

### do-while문

- 최소한 한번은 수행될 것을 보장

### 이름 붙은 반복문

- `break`문과 `continue`문에 이름을 지정해 줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다
  ```java
  Loop1 : for(int i = 2; i <= 9; i++) {
              for(int j = 1; j <= 9; j++) {
                  if(j == 5) break Loop1; // end for로 이동
              }
          }
          // end for
  ```

<br/>

## <a name="array"></a>배열

### 배열의 선언과 생성

배열 선언 : 참조변수를 위한 공간을 만드는 것
배열 생성

- 값을 저장할 수 있는 공간을 만드는 것
- `new 타입[길이]`

### 배열의 길이와 인덱스

- 컴파일러는 유효 범위를 벗어난 index 사용 실수를 걸러주지 못한다. 왜냐하면 index로 변수를 많이 사용하는데, 변수의 값은 실행 시에 대입되므로 컴파일러는 변수 값의 범위를 확인할 수 없다
- 배열의 길이
  - 양의 정수, 최대값은 int 타입의 최댓값(약 20억)
  - 길이가 0인 배열도 생성 가능
  - 한번 생성하면 길이를 변경할 수 없다

### 배열의 초기화

- 생성과 동시에 자신의 타입에 해당하는 기본값으로 자동 초기화
- 초기화시 `{}`에 아무것도 넣지 않으면 길이가 0인 배열을 생성
- `Arrays.toString(배열이름)` 메서드는 배열의 모든 요소를 `[첫번째 요소, 두번째 요소, ...]`과 같은 문자열로 만들어서 반환
- 배열의 이름을 출력하면 → `타입@주소`의 형식으로 출력
- 예외적으로 `char`배열은 `println` 메서드로 출력하면 각 요소가 구분자 없이 출력

### String 배열

```java
String[] name = {"Kim", "Park"};
```

- 특별히 `String`클래스만 "Kim"과 같이 큰따옴표로만 간략히 표현되는 것이 허용된다. 원래 `String`은 클래스 이므로 `new`연산자를 통해 객체를 생성해야한다
- `String`클래스는 `char`배열에 기능(메서드)을 추가한 것이다
- `char`배열과 `String`클래스의 차이점 → `String`객체는 읽을 수 있을 뿐 내용을 변경할 수 없다

<br/>

## <a name="object-oriented-programming"></a>객체지향프로그래밍

### 객체지향언어

프로그래밍 언어의 규칙들을 이용 → 코드 간에 관계를 보다 유기적으로 해 프로그램을 구성 → 코드의 재사용성이 높고, 유지보수가 용이

### 클래스

- 객체지향이론의 관점에서의 정의
  - 객체를 생성하기 위한 틀이며, 속성과 기능으로 정의
- 프로그래밍적인 관점에서의 정의
  - 서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것
  - 사용자 정의 타입

### 인스턴스

- 참조변수가 하나도 없는 인스턴스는 가비지 컬렉터에 의해 자동으로 메모리에서 제거

### 선언위치에 따른 변수의 종류

|       변수의 종류       |                            선언위치                            |          생성시기           |
| :---------------------: | :------------------------------------------------------------: | :-------------------------: |
|  멤버변수 - 클래스변수  |                          클래스 영역                           | 클래스가 메모리에 올라갈 때 |
| 멤버변수 - 인스턴스변수 |                          클래스 영역                           |  인스턴스가 생성되었을 때   |
|        지역변수         | 클래스 영역 이외의 영역<br/>(메서드, 생성자, 초기화 블럭 내부) | 변수 선언문이 수행되었을 때 |

- 인스턴스 변수
  - 인스턴스마다 고유한 상태를 유지해야하는 속성
- 클래스 변수
  - `static` 키워드 사용
  - 모든 인스턴스가 공통된 저장공간(변수)을 공유 → 모든 인스턴스들이 공통적인 값을 유지해야하는 속성
  - `클래스이름.클래스변수`와 같은 형식으로 사용
  - 클래스가 메모리에 로딩될 때 생성, 프로그램이 종료될 때 까지 유지
  - `public`을 앞에 붙이면 프로그램 내 어디서나 접근할 수 있는 전역변수의 성격을 갖는다

### 메서드

- 같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만 static메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다
- 클래스 메서드(static 메서드)와 인스턴스 메서드
  - 인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드를 클래스 메서드로 정의
  - 클래스 메서드는 인스턴스의 생성없이 사용 가능하기 때문에 클래스 메서드에서 인스턴스 변수를 사용할 수 없다
  - 메서드 내에서 인스턴스 변수를 사용하지 않는다면 클래스 메서드로 정의하는 것을 고려 → 인스턴스 메서드는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 클래스 메서드 보다 호출시간이 더 걸린다

### JVM 메모리 구조

- 응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당
- JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리
  - 메서드 영역
    - 프로그램 실행 중 어떤 클래스가 사용되면 → JVM은 `*.class` 파일을 분석 → 클래스 데이터, 클래스 변수를 저장
  - 힙 영역
    - 인스턴스, 인스턴스 변수 저장
  - 호출 스택
    - 메서드를 위한 메모리로, 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장, 메서드가 작업을 마지마 메모리 공간을 반환

<br/>

## <a name="exception-handling"></a>예외처리(exception handling)

### 프로그램 오류

<br/>

소스코드( _.java ) → 컴파일러 ( 오타, 잘못된 구문, 자료형 체크 등 ) → 컴파일 성공 → 클래스 파일( _.class ) → 클래스 파일을 실행

<br/>

발생시점에 따라,

- 컴파일 에러 : 컴파일 시 발생하는 에러
- 런타임 에러 : 프로그램 실행도중 발생하는 에러
  - 에러(error) : 프로그램 코드에 의해 수습될 수 없는 심각한 오류
  - 예외(exception) : 프로그램 코드에 의해 수습될 수 있는 미약한 오류
    - 프로그래머가 적절한 코드를 작성해 프로그램의 비정상적인 종료를 막을 수 있다
- 논리적 에러 : 컴파일도 잘되고, 실행도 잘되지만 의도와 다르게 동작하는 것

<br/>

### 예외 클래스의 계층구조

자바는 실행 시 발생할 수 있는 모든 `Error`와 `Exception`을 클래스로 정의하였다

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/43d696ef-0dfc-478c-baa4-874368410979/java-exception_1.png](https://user-images.githubusercontent.com/7088950/80301746-de496f00-87e0-11ea-976c-ed8d7785d7c6.png)

[출처] [https://kookyungmin.github.io/language/2018/06/06/java_18/](https://kookyungmin.github.io/language/2018/06/06/java_18/)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa7258c4-0579-42f7-b649-079128d0d382/java-exception_2.png](https://user-images.githubusercontent.com/7088950/80301758-f91be380-87e0-11ea-89a1-2a8994149df9.png)

[출처] [https://kookyungmin.github.io/language/2018/06/06/java_18/](https://kookyungmin.github.io/language/2018/06/06/java_18/)

<br/>

`Exception` 클래스들은 두 그룹으로 나눌 수 있다

- `RunTimeException`클래스와 그 자손들 : 프로그래머의 실수로 발생하는 예외
- `Exception`클래스와 `RunTimeException`클래스와 그 자손들을 제외한 클래스들 : 외적인 요인에 의해 발생하는 예외( 사용자들의 동작에 의해서 발생하는 경우가 많다 )

<br/>

### 예외 처리하기

> 프로그램의 실행도중에 발생하는 에러는 어쩔 수 없지만, 예외는 프로그래머가 이에 대한 처리를 미리 해주어야 한다.

- 예외가 발생하면, 발생한 예외에 해당하는 클래스의 인스턴스가 만들어진다
- 처리되지 못한 예외는 JVM의 예외처리기(`UncaughtExceptionHandler`)가 받아서 예외의 원인을 화면에 출력한다
- 예외의 종류와 일치하는 단 한 개의 `catch` 블럭만 수행된다

<br/>

예외 정보를 출력

- `printStacktTrace()` : 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력
- `getMessage()` : 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다

```
// ExceptionEx8.java 파일의 7번째 줄에서 0으로 나누는 연산을 했을 때
// printStackTrace()가 출력하는 정보
java.lang.ArithmeticException: / by zero
      at ExceptionEx8.main(ExceptionEx8.java:7)

// getMessage()가 출력하는 정보
/ by zero
```
