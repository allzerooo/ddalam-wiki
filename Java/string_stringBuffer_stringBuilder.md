# String, StringBuffer, StringBuilder

## 1. String

### 변경 불가능한(immutable) 클래스

```java
String hello = "Hello";
String world = "World";
hello = hello + world;
```

String 인스턴스가 갖고 있는 문자열은 읽을 수만 있고, 변경할 수는 없다. `hello + world` 처럼 문자열을 변경하는 연산을 하면 변경된 문자열을 가지는 String 인스턴스가 생성된다.

<br/>

### 생성 : 문자열 리터럴 vs 생성자

문자열을 만들 때는 문자열 리터럴을 지정하는 방법과 생성자를 사용하는 방법이 있다. 문자열 리터럴을 지정하는 방법은 이미 존재하는 것을 재사용하고, 생성자를 사용하는 방법은 `new` 연산자에 의해 메모리 할당이 이루어지기 때문에 항상 새로운 String 인스턴스가 생성된다. 

<br/>

**문자열 리터릴을 지정하는 방법**

```java
String str1 = "hello";
String str2 = "hello";
```

문자열 리터럴을 사용하면 `str1`과 `str2`는 같은 주소를 참조한다. 

<br/>

**생성자를 사용하는 방법**

```java
String str1 = new String("hello");
String str2 = new String("hello");
```

생성자를 사용하면 `str1`과 `str2`는 서로 다른 주소를 참조한다.

`equals()`를 사용하면 두 문자열의 내용을 비교하기 때문에 두 방법 모두 `true`를 결과로 얻지만, 주소를 비교하는 `==`를 사용했을 때는 다른 결과를 얻는다.

<br/>

### 문자열 리터럴

자바 소스파일에 포함된 모든 문자열 리터럴은 컴파일 시에 클래스 파일에 저장된다. 해당 클래스 파일이 클래스 로더에 의해 메모리에 올라갈 때 리터럴들은 JVM에 있는 **상수 저장소(constant pool)**에 저장된다. 이 때 같은 내용의 문자열 리털럴은 **한번만 저장**된다. 문자열 리터럴도 String 인스턴스이고, 한번 생성하면 내용을 변경할 수 없으니 하나의 인스턴스를 공유하면 되기 때문이다.

<br/>

### 문자열 연결은 느리다

문자열은 불변이기 때문에 두 문자열을 연결할 경우 양쪽 내용을 모두 복사해야 한다. **문자열 연결 연산자로 문자열 n개를 잇는 시간은 n^2에 비례한다.** 따라서, 한 줄짜리 출력값 혹은 작고 크기가 고정된 객체의 문자열 표현을 만들때라면 괜찮지만 어떤 경우에는 성능 저하를 감내하기 어렵다. 성능에 신경을 많이 써야 한다면 `StringBuffer` 또는 `StringBuilder`의 `append()`를 사용하는게 좋다.

<br/>
<br/>

## 2. StringBuffer

### 변경 가능한(mutable) 클래스

내부적으로 편집을 위한 버퍼를 가지고 있으며, 인스턴스를 생성할 때 버퍼의 크기를 지정할 수 있다. 문자열이 버퍼의 길이를 넘어서게 되면 버퍼의 길이를 늘려주는 작업이 추가로 수행되어야하기 때문에 효율이 떨어질 수 있으니, 버퍼의 길이를 충분히 잡아주는 것이 좋다. (기본 크기 : 16)

또한, 동기화를 지원하는데 이 말은 멀티스레드 환경에서 안전하다는 것을 뜻한다. 한 스레드가 `StringBuffer` A객체에 접근 중일 때 다른 스레드의 접근을 막는다.

<br/>
<br/>

## 3. StringBuilder

"그저 동기화하지 않은 `StringBuffer`다"

동기화가 StringBuffer의 성능을 떨어뜨린다. `StringBuilder`는 `StringBuffer`에서 스레드 동기화를 뺀 것 외에 완전히 똑같은 기능으로 동작한다.

<br/>

---

<br/>

출처

- Java의 정석 - 남궁 성
- Effective Java - 조슈아 블로크