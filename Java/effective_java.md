# Effectvie Java

Effective Java(조슈아 블로크)

<br/>

- [Effectvie Java](#effectvie-java)
  - [객체 생성과 파괴](#객체-생성과-파괴)
    - [<a name="itme7"></a>아이템 7. 다 쓴 객체 참조를 해제하라](#아이템-7-다-쓴-객체-참조를-해제하라)
    - [<a name="itme8"></a>아이템 8. finalizer와 cleaner 사용을 피하라](#아이템-8-finalizer와-cleaner-사용을-피하라)
    - [<a name="itme9"></a>아이템 9. try-finally 보다는 try-with-resources를 사용하라](#아이템-9-try-finally-보다는-try-with-resources를-사용하라)
  - [모든 객체의 공통 메서드](#모든-객체의-공통-메서드)
    - [<a name="itme10"></a>아이템 10. equals는 일반 규약을 지켜 재정의하라](#아이템-10-equals는-일반-규약을-지켜-재정의하라)
    - [<a name="itme11"></a>아이템11. equals를 재정의하려거든 hashCode도 재정의하라](#아이템11-equals를-재정의하려거든-hashcode도-재정의하라)
    - [<a name="itme12"></a>아이템12. toString을 항상 재정의하라](#아이템12-tostring을-항상-재정의하라)
    - [<a name="itme13"></a>아이템13. clone 재정의는 주의해서 진행하라](#아이템13-clone-재정의는-주의해서-진행하라)
    - [<a name="itme14"></a>아이템14. Comparable을 구현할지 고려하라](#아이템14-comparable을-구현할지-고려하라)
  - [일반적인 프로그래밍 원칙](#일반적인-프로그래밍-원칙)
    - [<a name="itme61"></a>아이템61. 박싱된 기본 타입보다는 기본 타입을 사용하라](#아이템61-박싱된-기본-타입보다는-기본-타입을-사용하라)
  - [예외](#예외)
    - [<a name="itme69"></a>아이템69. 예외는 진짜 예외 상황에만 사용하라](#아이템69-예외는-진짜-예외-상황에만-사용하라)

<br/>

## 객체 생성과 파괴

### <a name="itme7"></a>아이템 7. 다 쓴 객체 참조를 해제하라

가비지 컬렉터는 다 쓴 객체의 참조를 해제하지 않았을 때 해당 참조가 유효한지 알 수 없는 경우가 있다. 따라서, 해당 참조를 다 썼을 때 null 처리를 해줘야 된다. 하지만 모든 객체를 다 쓰자마자 일일이 null 처리를 할 필요는 없다. 객체 참조를 null 처리해야 되는 경우는 대표적으로 다음 3가지 경우이다.

1. 자기 메모리를 직접 관리하는 클래스
2. 객체 참조를 캐시에 넣고 사용했을 때
3. 클라이언트가 콜백(callback)을 등록했을 때

<br/>

### <a name="itme8"></a>아이템 8. finalizer와 cleaner 사용을 피하라

<br/>

### <a name="itme9"></a>아이템 9. try-finally 보다는 try-with-resources를 사용하라

`try-with-resources` 구조를 사용하려면 닫아야 하는 자원 클래스는 반드시 `AutoCloseable` 인터페이스를 구현해야 한다.
(AutoCloseable 인터페이스는 void를 반환하는 `close` 메서드 하나만 정의된 인터페이스다)

```java
static void copy(String src, String dst) {
    try (InputStream in = new FileInputStream(src);
        OutputStream out = new FileOutputStream(dst)) {
            byte[] buf = new byte[BUFFER_SIZE];
            int n;
            while ((n = in.read(buf)) >= 0)
                out.write(buf, 0, n);
        }
}
```

`close`는 코드에 나타나지 않지만, `close`에서 발생한 예외는 숨겨지고(스택 추적 내역에서 찾을 수 있고, `Throwable`의 `getSuppressed` 메서드를 이용하면 프로그램 코드에서 가져올 수 있다) try문 안에서 발생한 예외가 기록된다.
`try-with-resources`에서도 예외는 던질 수 있고, `catch` 절을 쓸 수도 있다.

<br/>
<br/>

## 모든 객체의 공통 메서드

`Object`클래스의 `final`이 아닌 메서드(`equals`, `hashCode`, `toString`, `clone`, `finalize`)는 모두 재정의(`overriding`)를 염두에 두고 설계되었고, 재정의 시 지켜야 하는 규약이 명확히 정의되어 있다. 그래서 `Object를` 상속하는 모든 클래스는 이 메서드들을 규약에 맞게 재정의해야 한다. 메서드를 잘못 구현하면 클래스가 이 규약을 준수한다고 가정하는 클래스를 오작동하게 만들 수 있다

<br/>

### <a name="itme10"></a>아이템 10. equals는 일반 규약을 지켜 재정의하라

재정의하지 않아도 되는 경우

- 클래스가 값을 표현하는게 아니라 동작하는 개체를 표현하는 클래스일 때 (ex. Thread. Object의 equals 메서드는 이러한 클래스에 적합하게 구현되었다)
- 물리적으로 같은가가 아닌 논리적으로 같은가를 검사할 일이 없을 때 (ex. java.util.regex.Pattern은 equals를 재정의해서 두 Pattern의 인스턴스가 같은 정규표현식을 나타내는지 검사한다)
- 상위 클래스에서 재정의한 `equals`가 하위 클래스에도 딱 들어맞을 때 (ex. Set의 구현체는 AbstractSet이 구현한 equals를 상속받아 쓰고, List 구현체는 AbstractList로 부터, Map 구현체는 AbstractMap으로부터 상속받아 그대로 쓴다)
- 클래스가 `private`이거나 `package-private`이고 `equals` 메서드를 호출할 일이 없을 때

<br/>

재정의해야 하는 경우

- 두 객체가 논리적으로 같은가를 확인해야 하는데 상위 클래스의 `equals`가 논리적 동치성을 비교하도록 재정의되지 않았을 때 (주로 값 클래스들이 해당됨)

<br/>

`eqauls` 메서드를 재정의할 때 지켜야 하는 규약

```
null이 아닌 모든 참조값 x, y, z에 대해
x.eqauls(x)는 true
x.eqauls(y)가 true면 y.equals(x)도 true
x.equals(y)가 true이고, y.equals(z)도 true면, x.eqauls(z)도 true
x.equals(y)를 반복해서 호출하면 항상 true 또는 항상 false를 반환
x.equals(null)은 false
```

<br/>

### <a name="itme11"></a>아이템11. equals를 재정의하려거든 hashCode도 재정의하라

논리적으로 같은 객체는 같은 해시코드를 반환해야 한다. equals는 물리적으로 다른 두 객체를 논리적으로 같다고 할 수 있지만 Object의 기본 hashCode 메서드는 두 객체를 다르다고 판단한다. 따라서 equals를 재정의할 때는 hashCode도 반드시 재정의해야 한다.

<br/>

hashCode를 재정의 할 때 지켜야 하는 규약

- equals 비교에 사용되는 정보가 변경되지 않았다면 hashCode 메서드는 몇 번을 호출해도 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 달라져도 상관없다.
- equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode도 같은 값이어야 한다.
- equals(Object)가 두 객체를 다르다고 판단했더라도 두 객체의 hashCode가 다른 값일 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.

<br/>

좋은 해시 함수

- 서로 다른 인스턴스에 다른 해시코드를 반환한다(3번 규약)
- 이상적인 해시 함수는 주어진 서로 다른 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다

<br/>

좋은 hashCode 작성 방법

<br/>

### <a name="itme12"></a>아이템12. toString을 항상 재정의하라

- 모든 하위 클래스에서 재정의해야 하며, 간결하면서 사람이 읽기 쉬운 형태의 유익한 정보를 반환해야 한다
- `println`, `printf`, 문자열 연결 연산자(+), `assert` 구문에 넘길 때, 디버거가 객체를 출력할 때, 오류 메시지를 로깅할 때 등 개발자가 직접 호출하지 않아도 다른 어딘가에서 호출되어 쓰일 수 있다
- 객체가 가진 주요 정보를 모두 반환하는게 좋다
- 객체가 거대하거나 문자열로 표현하기에 적합하지 않다면, 요약 정보를 담아야하며 이상적으로는 객체 스스로를 완벽히 설명하는 문자열이어야 한다
- 반환값의 포맷을 명시할지, 하지 않을지 결정해야 한다. 포맷을 명시하든 안하든 중요한 것은 의도를 명확히 밝히는 것이다
- 포맷 명시 여부와 상관없이 반환값에 포함된 정보를 얻어올 수 있는 API를 제공해야 한다
- 정적 유틸리티 클래스, 대부분의 열거 타입은 `toString`을 재정의하지 않아도 된다
- 하위 클래스들이 공유해야 할 문자열 표현이 있는 추상 클래스라면 `toString`을 재정의해줘야 한다

<br/>

### <a name="itme13"></a>아이템13. clone 재정의는 주의해서 진행하라

clone 보다 복사 생성자와 복사 팩터리가 더 나은 객체 복사 방식을 제공할 수 있다. 인터페이스 기반 복사 생성자와 복사 팩터리의 더 장확한 이름은 '변환 생성자(conversion constructor)'와 '변환 팩터리(conversion factory)'다.

- 복사 생성자

```java
public Yum(Yum yum) { ... }
```

- 복사 팩터리

```java
public static Yum newInstance(Yum yum) { ... }
```

<br/>

배열만이 clone 메서드 방식에 가장 합당한 경우이다

<br/>

### <a name="itme14"></a>아이템14. Comparable을 구현할지 고려하라

Comparable을 구현했다는 것은 그 클래스의 인스턴스들에는 순서가 있음을 뜻한다. 그래서 Comparable을 구현한 객체들의 배열은 손쉽게 정렬할 수 있다

```java
Arrays.sort(a);
```

<br/>

순서가 명확한 값 클래스를 작성한다면 반드시 Comparable 인터페이스를 구현하자.

<br/>

compareTo()

- Comparable 인터페이스의 유일한 메서드
- 단순 동치성 비교에 더해 순서까지 비교할 수 있으며, 제네릭하다

<br/>

compareTo 메서드의 일반 규약

<br/>

## 일반적인 프로그래밍 원칙

### <a name="itme61"></a>아이템61. 박싱된 기본 타입보다는 기본 타입을 사용하라

자바의 데이터 타입은 크게 두 가지로 나눌 수 있다. 기본 타입과 참조 타입이다. 각각의 기본 타입에는 대응하는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다. 오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수는 있지만, 그렇다고 차이가 사라지는 것은 아니기 때문에 주의해서 선택해야 한다.

<br/>

**기본 타입과 박싱된 기본 타입의 주된 차이**
1. 기본 타입은 값만 가지고 있지만, 박싱된 기본 타입은 값과 식별성(identity)란 속성을 갖는다
    - 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다
    - 박싱된 기본 타입에 `==` 연산자를 사용하면 식별성 검사를 하기 때문에 값은 같더라도 비교의 결과는 `false`이다. 따라서 박싱된 기본 타입의 값을 비교하려면, 기본 타입으로 저장한 다음 비교를 수행해야 한다
2. 기본 타입의 값은 언제나 유효하지만, 박싱된 기본 타입은 유효하지 않은 값(`null`)을 가질 수 있다
    - 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다. 그리고 `null` 참조를 언박싱하면 `NullPointException`이 발생한다
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다

<br/>

**박싱된 기본 타입은 언제 써야 하는가?**
1. 컬렉션의 원소, 키, 값으로 쓴다
    - 컬렉션은 기본 타입을 담을 수 없으므로
2. 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로 쓴다
    - 타입 매개변수로 기본 타입을 지원하지 않기 때문에
3. 리플렉션을 통해 메서드를 호출할 때


<br/>

## 예외 

### <a name="itme69"></a>아이템69. 예외는 진짜 예외 상황에만 사용하라

- 코드를 ```try-catch``` 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다
- 예외는 오직 예외 상황에서만 써야한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안 되며, 이를 프로그래머에게 강요하는 API를 만들어서도 안 된다
- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다
- 특정 상태에서만 호출할 수 있는 '상태 의존적' 메서드를 제공하는 클래스는 '상태 검사' 메서드도 함께 제공해야 한다. 
  - ```Iterator``` 인터페이스의 ```next```와 ```hasNext```가 각각 상태 의존적 메서드와 상태 검사 메서드에 해당한다
  - 별도의 상태 검사 메서드 덕분에 다음과 같은 표준 for 관용구를 사용할 수 있다(```for-each```도 내부적으로 ```hasNext```를 사용한다)
    ```java
    for (Iterator<Foo> i = collection.iterator(); i.hasNext();) {
        Foo foo = i.next();
        ...
    }
    ```
- 상태 검사 메서드 대신, 올바르지 않은 상태일 때 빈 옵셔널 혹은 null 같은 특수한 값을 반환하는 방법도 있다
- 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침 몇개
  - 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문이다
  - 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다
  - 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다. 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기가 쉽다. 상태 검사 메서드 호출을 잊었다면 상태 의존적 메서드가 예외를 던져 버그를 확실히 드러낼 것이다. 반면 특정 값은 검사하지 않고 지나쳐도 발견하기가 어렵다(옵셔널에는 해당하지 않는 문제다)