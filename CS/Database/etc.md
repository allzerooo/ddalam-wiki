## InnoDB
- MySQL을 위한 데이터베이스 엔진
- B+Tree를 사용하지만, 일반적인 B+Tree 보다 복잡하게 구현되어 있다
- 같은 레벨의 노드들끼리 Double Linked List로 연결되어 있다

<br/>

## 인덱스(Index)
- 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
- 인덱스 사용하지 않은 컬럼을 조회해야 하는 상황이라면 전체를 탐색하는 Full Scan을 수행해야 한다
- DBMS는 인덱스 정렬된 상태로 유지해야 되기 때문에 Index가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행되면 각각 다음과 같은 연산을 추가적으로 해줘야한다
  - INSERT : 새로운 데이터에 대한 인덱스를 추가
  - DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
  - UPDATE : 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함
- 장점
  - 테이블을 조회하는 속도 향상
  - 전반적인 시스템 부하를 줄일 수 있다
- 단점
  - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다
  - 인덱스를 관리하기 위해 추가 작업이 필요하다
  - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다
- 인덱스를 사용하면 좋은 경우
  - INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
  - JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 인덱스의 자료구조
  - 가장 대표적으로 해시 테이브과 B+Tree가 사용된다
  - 해시 테이블
    - key : 컬럼 값, value : 데이터의 위치
    - but, 해시 테이블이 사용되는 경우는 제한적 → 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하기 때문에 부등호 연산이 자주 사용되는 데이터베이스 검색에는 적합하지 않은 경우가 많기 때문
  - B+Tree
    - 리프 노드들을 Linked List로 연결해 순차검색에 용이
    - 브랜치 노드에는 key만 담아두고, 오직 리프 노드에 key, data를 저장
    - 리프 노드를 제외하고 데이터를 담지 않기 때문에 메모리를 더 확보 → 하나의 노드에 더 많은 key들을 수용할 수 있다 → 트리의 높이가 낮아진다 → 탐색을 빠르게 할 수 있다
    - 풀 스캔 시 리프 노트의 데이터를 한 번만 선형탐색하면 된다

---

<br>

- [위키백과 InnoDB](https://ko.wikipedia.org/wiki/InnoDB)
- [[MySQL] B-tree, B+tree란? (인덱스와 연관지어서)](https://zorba91.tistory.com/293)
- [[Database] 인덱스(index)란?](https://mangkyu.tistory.com/96?category=761304)